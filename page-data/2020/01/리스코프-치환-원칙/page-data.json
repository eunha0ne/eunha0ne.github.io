{"componentChunkName":"component---src-templates-post-js","path":"/2020/01/리스코프-치환-원칙/","result":{"data":{"markdownRemark":{"html":"<h2>The Liskov Substitution Principle</h2>\n<p>리스코프 치환 원칙은 상속 계층 안에서의 객체간의 상호 운용과 연관되어 있다. </p>\n<p>하위 타입(subtype)은 상위 타입(base type)에 대용-치환되어야 한다. 객체지향 프로그래밍에서 상속은 코드를 공유하는 매커니즘 제공한다. 이는 연관된 타입의 계층 안에서 이루어지며 상위 타입 안에서 공통 데이터와 행위를 캡슐화하면서 달성된다. 그리고 분화한 타입(specialized type)에 대한 정의는 상위 타입의 관점에서 이루어진다.</p>\n<p>리스코프 치환 원칙을 고수하기 위해서는 파생된 타입은 상위 타입에서 동작하도록 기대되는 행위와 의미론적으로 동등해야 한다. 예를들어 하위 타입에서 상위 타입을 상속하면서 상위 타입의 행위를 하위 타입 안에서 재정의한 경우에 상위 타입에서 수용할 수 있는 기능의 범위를 벗어나게 된다면 리스코프 치환 원칙을 위배했다고 볼 수 있다. 다시말해 하위 타입에서 정의된 행위는, 상위 타입 안에서 기대한대로 동등하게 동작할 수 있도록 고려되어야 한다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"http://aspiringcraftsman.com/2011/12/31/solid-javascript-the-liskov-substitution-principle/\">http://aspiringcraftsman.com/2011/12/31/solid-javascript-the-liskov-substitution-principle/</a></li>\n</ul>","frontmatter":{"title":"리스코프 치환 원칙","tags":["요약","2020"],"date":"08 February, 2020"},"headings":[{"value":"The Liskov Substitution Principle","depth":2},{"value":"참고","depth":2}]}},"pageContext":{"slug":"/2020/01/리스코프-치환-원칙/","prev":{"node":{"headings":[],"fields":{"slug":"/2020/01/악당은-아니지만-지구정복/"},"frontmatter":{"title":"악당은 아니지만 지구정복","tags":["안시내","독서","요약","2020"]}}},"next":{"node":{"headings":[{"value":"Object-oriented Programming"},{"value":"설계 원칙, SOLID"},{"value":"주요 개념"},{"value":"참고"}],"fields":{"slug":"/2020/01/객체지향-프로그래밍/"},"frontmatter":{"title":"객체지향 프로그래밍","tags":["요약","2020"]}}}}}}