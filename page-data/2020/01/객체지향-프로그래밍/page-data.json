{"componentChunkName":"component---src-templates-post-js","path":"/2020/01/객체지향-프로그래밍/","result":{"data":{"markdownRemark":{"html":"<h2>Object-oriented Programming</h2>\n<p>객체지향 프로그래밍은 실세계에 존재하고 인지하고 있는 객체(Object)를 소프트웨어의 세계에서 표현하기 위해 <strong>객체의 핵심적인 개념 또는 기능만을 추출하는 추상화(Abstraction)를 통해 모델링하려는 프로그래밍 패러다임</strong>을 말한다. 다시 말해, 우리가 주변의 실세계에서 사물을 인지하는 방식을 프로그래밍에 접목하려는 사상을 의미한다.</p>\n<p>각 객체는 메시지를 받을 수도 있고, 데이터를 처리할 수도 있으며, 또다른 객체에게 메시지를 전달할 수도 있다. 각 객체는 별도의 역할이나 책임을 갖는 작은 독립적인 기계 또는 부품으로 볼 수 있다.</p>\n<h2>설계 원칙, SOLID</h2>\n<ul>\n<li>\n<p>단일 책임 원칙: Single Responsibility Principle</p>\n<ul>\n<li>모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 한다.</li>\n<li>한 클래스를 한 관심사에 집중하도록 유지하는 것이 중요한 이유는, 이것이 클래스를 더욱 튼튼하게 만들기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p>개방-폐쇄 원칙: Open-closed Principle</p>\n<ul>\n<li>소프트웨어 개체(entities), 즉 클래스, 모듈, 함수 등은 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.</li>\n<li>코드를 수정할 때 그 모듈을 이용하는 다른 모듈을 줄줄이 고쳐야 한다면, 이와 같은 프로그램은 수정하기 어렵다고 볼 수 있다. 기능을 수정할 때 원래 코드를 변경하지 않고, 새로운 코드를 추가해도 기능이 동작 가능하도록 하는 것이다.</li>\n</ul>\n</li>\n<li>\n<p>리스코프 치환 원칙: Liskov Subsitution Principle</p>\n<ul>\n<li>하위 타입은 상위 타입에 대용-치환되어야 한다. 파생된 타입은 상위 타입에서 동작하도록 기대되는 행위와 의미론적으로 동등해야 한다.</li>\n</ul>\n</li>\n<li>인터페이스 분리 원칙: Interface Segregation Principle</li>\n<li>의존관계 역전 원칙: Dependency Inversion Principle</li>\n</ul>\n<h2>주요 개념</h2>\n<ul>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A9%94%EC%84%9C%EB%93%9C\">Object, Property, and method</a></li>\n<li>Class</li>\n<li>Encapsulation</li>\n<li>Abstraction</li>\n<li>Reusability/inheritance</li>\n<li>Polymorphism</li>\n<li>Association</li>\n<li>Aggregation</li>\n<li>Composition</li>\n</ul>\n<h3>객체, 프로퍼티 그리고 메서드</h3>\n<h3>클래스</h3>\n<h3>캡슐화</h3>\n<h3>추상화</h3>\n<h3>재사용성과 상속</h3>\n<h3>다형성</h3>\n<h2>참고</h2>\n<ul>\n<li>객체지향의 사실과 오해,</li>\n<li><a href=\"http://aspiringcraftsman.com/2011/12/31/solid-javascript-the-liskov-substitution-principle/\">http://aspiringcraftsman.com/2011/12/31/solid-javascript-the-liskov-substitution-principle/</a></li>\n<li><a href=\"https://poiemaweb.com/js-object-oriented-programming\">https://poiemaweb.com/js-object-oriented-programming</a></li>\n<li><a href=\"https://medium.com/better-programming/object-oriented-programming-in-javascript-b3bda28d3e81\">https://medium.com/better-programming/object-oriented-programming-in-javascript-b3bda28d3e81</a></li>\n</ul>","frontmatter":{"title":"객체지향 프로그래밍","tags":["요약","2020"],"date":"01 February, 2020"},"headings":[{"value":"Object-oriented Programming","depth":2},{"value":"설계 원칙, SOLID","depth":2},{"value":"주요 개념","depth":2},{"value":"객체, 프로퍼티 그리고 메서드","depth":3},{"value":"클래스","depth":3},{"value":"캡슐화","depth":3},{"value":"추상화","depth":3},{"value":"재사용성과 상속","depth":3},{"value":"다형성","depth":3},{"value":"참고","depth":2}]}},"pageContext":{"slug":"/2020/01/객체지향-프로그래밍/","prev":{"node":{"headings":[{"value":"The Liskov Substitution Principle"},{"value":"참고"}],"fields":{"slug":"/2020/01/리스코프-치환-원칙/"},"frontmatter":{"title":"리스코프 치환 원칙","tags":["요약","2020"]}}},"next":{"node":{"headings":[],"fields":{"slug":"/2020/01/박정준-강연-요약/"},"frontmatter":{"title":"혁신의 파도에 올라타기 위해 반드시 찾아야 하는 것","tags":["박정준","강연","요약","2020"]}}}}}}